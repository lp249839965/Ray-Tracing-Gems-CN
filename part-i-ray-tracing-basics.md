# Ray Tracing Gems

## 序言

光线追踪已经成为实时渲染的核心组成部分。我们现在有了加速射线跟踪的消费级别的GPUs和APIs，但是我们也需要一些让光线追踪能够运行在60帧每秒或更多帧数，同时为每帧提供高质量的图像的算法。这就是这本书的内容。

序言很容易被跳过，但是我们想让你知道两件事：

* 有关本书的补充代码及其他资料，请参阅 [http://raytracinggems.com](http://raytracinggems.com)
* 这本书所有的内容，都是公开的。

第二个听起来并不令人兴奋，但这意味着你可以自由地复制和再版任何章节或整本书，只要你确保着不会被用于商业目的。具体许可是Creative Commons（CC-BY-NC-ND）[https://creativecommons.org/licenses/by-nc-nd/4.0/](https://creativecommons.org/licenses/by-nc-nd/4.0/)  我们这样做是为了让作者和其他人能够尽快传播这卷书中的信息。

_//接下来是感谢的内容_

## 前言
**by Turner Whitted and Martin Stich**
我从未想过光线追踪会为全局光照提供终极的载体，但它的简洁性使其具有持续的吸引力。 很少有图形渲染算法易于可视化，解释或编码。 这种简单性使新手程序员可以轻松渲染几个透明球体和由点光源照射的棋盘。 在现代实践中，光线跟踪的原始算法和它的进阶版本的实现有点复杂，但是它们仍然是沿着简单的直线路径上的相交。

“令人难堪的并行”一词早在任何能运行它的并行引擎出现之前就应用于光线跟踪了。如今，光线跟踪在现代GPU的惊人的并行性和原始计算能力方面达到了它的匹配。

对于所有程序员来说，可访问性一直是一个问题。几十年前，如果一台电脑做不到我想要它做的事情，我会在它后面走来走去，对电路做一些小小的改动。(我不是开玩笑的)。在以后的几年里，甚至可以在图形API的层下查看以添加自定义。在后来的几年中，甚至在图形API的下层进行对等访问以添加自定义也变得不可思议。几十年前，随着可编程shading的逐渐扩展，这种情况发生了微妙的变化。当今GPU的灵活性以及支持的编程工具,提供了对并行处理元素的全部计算潜力的访问。

那么，如何实现实时光线追踪的呢？显然，在性能、复杂性和准确性方面的挑战并没有使图形程序员同时获得更高的质量和更高的精度、速度。图形处理器具有良好的性能，因此光线跟踪不再是圆孔中的方形钉。在图形硬件中引入显式的光线跟踪加速的特性，是实现实时光线跟踪应用的重要一步。结合光线追踪的简单性，固有的平行性，可达性和强力的现代GPU提供的实时光线跟踪性能，可以满足每个图形程序员的需求。 然而，获得驾驶执照并不像赢得汽车比赛那样。 有技巧可以学习，有经验可以分享。 就像任何一门学科一样，这门学科也有诀窍。当那些技巧和技术被贡献给本文的专家们分享时，它们真的变成了精粹。
____
对于图形学来说，这是一个令人激动的时刻！我们已经进入到实时光线追踪的时代——每个人都知道这个时代会到来，但知道最近，我们才意识到几年或者十几年之后。最近的一次Big bang是在2001年，那时出现了支持可编程着色的硬件和API，这对于开发者来说提供了无限的可能。可编程着色技术促进了非常多的渲染技术的发明，很多书都介绍了这些例如我们这本书（其他例如：Real-Time Rendering 和 GPU Gems）。在过去的几年里，这些技术的不断发展便随着越来越强大的GPU，成为了实时计算机图形学的主要驱动力。得益于这些进步，游戏和其他的图形应用变的更加的漂亮。

可是，尽管现在仍在取得进步，但是，基于光栅化的渲染已经到达了瓶颈。特别的，当我们涉及到模拟灯光的时候（真实感渲染的本质），获得的收益已经到达了逐步递减的程度。这是因为，任何形式的光路传输模拟所需要的基本操作，光栅化都无法提供—这项能力是能够从场景中的任何一个点来询问“我周围有什么?”。由于这非常的基本，过去几十年的大多数发明的重要的光栅化技术的内核，都由于这种限制采取了聪明的变通方案。他们一般采取预先生成一些包含场景近似信息的数据结构，然后在着色阶段利用这种数据结构中进行查找和进行其他操作。

阴影贴图，光照烘焙贴图，屏幕空间反射，AO，光照探针，体素网格都是这种变通方案的例子。他们共同面临的问题是，他们所依赖的辅助数据结构的保真度是有限的。这些数据结构必然只包含简化的表示，因为除了最微不足道的场景之外，在所有情况下都是不可行的，由于预计算和存储他们的数量和分辨率需要精确的结果。因此，基于这些数据结构的技术都有不可避免的导致明显的呈现伪阴影影或完全丢失效果的失败情况。这就是为什么接触阴影（Contact Shadows）看起来并不是完全正确，镜头前面的物体失去反射，间接光的细节很粗糙例如等等。更重要的是，这些技术都需要手动调参，才能得到最好的效果。

进入到光线追踪，光线追踪能够优雅并准确的解决这些问题，因为它精确的提供了光栅化技术试图去模拟的基本操作：允许我们在场景的任何地方去发起查询到我们喜欢的任何方向，并且找到哪些物体会被击中，并且这一段的距离是多少。这可以通过检查场景中实际的几何信息得到，不限于近似值。因此，基于光线追踪的计算是足够的准确去模拟各种光线传输，并且拥有很好的细节精度。当我们的目标是照片级别的时候，我们需要确定光子穿过虚拟世界的复杂路径，这种能力是其他方法无可替代的。光线跟踪是真实感渲染的基本要素，这就是为什么它对实时域的引入是计算机图形学的重要一步。

当然，使用光线追踪生成图形并不是一个新的idea。源头可以追溯到上世纪60年代，并且电影渲染和设计可视化的应用几十年来都得益于这项成果。那么，什么是新的呢?那就是在现代系统中处理光线的速度。得益于专用的光线追踪芯片，通过测算，最近推出的NVIDIA的图灵GPU的吞吐量以每秒数十亿条光线计算，比上一代产品提高了一个数量级。实现这种性能水平的硬件称为RT Core，这是一个经过多年研究和开发的复杂单元。 RT核心与GPU上的流式多处理器（SMs）紧密耦合，并实现光线跟踪操作的关键“内环”：边界体积层次结构（BVH）的遍历和光线与三角形的交叉测试。在专用电路中执行这些计算不仅比软件实现更快，而且还暴露出通用SM内核以执行其他工作，例如着色，同时并行处理光线。 通过RT Cores实现的性能的巨大飞跃为光线追踪奠定了基础，使其在要求苛刻的实时应用中变得可行。

想要应用程序，尤其是游戏，能够有效的利用RT Cores,还需要创建新的API，这些API可以无缝的继承到已经建立的ecosys tems中。在和微软的密切合作下，DirectX光线跟踪（DXR）开发成为DirectX 12不可或缺的一部分。这将在第3章提供了一个介绍。 Vulkan的NV_ray_tracing扩展在Khronos API暴露了相同的概念。
